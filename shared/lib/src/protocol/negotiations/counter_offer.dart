import 'package:serverpod/serverpod.dart';
import 'package:json_annotation/json_annotation.dart';
import '../auth/user.dart';

part 'counter_offer.g.dart';

@JsonSerializable()
class CounterOffer extends SerializableEntity {
  @override
  int? id;

  String offerId;
  String negotiationId;
  String? parentOfferId; // Reference to the offer being countered
  int userId;
  UserType userType;
  double amount;
  String? message;
  DateTime createdAt;
  DateTime? expiresAt;
  CounterOfferStatus status;
  String? rejectionReason;
  DateTime? respondedAt;
  Map<String, dynamic>? metadata;

  // Additional negotiation context
  double? originalAmount;
  double? suggestedAmount;
  int offerSequence; // 1st offer, 2nd counter, etc.
  bool isAutoGenerated; // Generated by AI vs manual

  CounterOffer({
    this.id,
    required this.offerId,
    required this.negotiationId,
    this.parentOfferId,
    required this.userId,
    required this.userType,
    required this.amount,
    this.message,
    required this.createdAt,
    this.expiresAt,
    this.status = CounterOfferStatus.pending,
    this.rejectionReason,
    this.respondedAt,
    this.metadata,
    this.originalAmount,
    this.suggestedAmount,
    this.offerSequence = 1,
    this.isAutoGenerated = false,
  });

  // Check if offer is expired
  bool get isExpired {
    return expiresAt != null && DateTime.now().isAfter(expiresAt!);
  }

  // Check if offer is still active
  bool get isActive {
    return status == CounterOfferStatus.pending && !isExpired;
  }

  // Calculate percentage difference from original amount
  double? get percentageChange {
    if (originalAmount == null || originalAmount == 0) return null;
    return ((amount - originalAmount!) / originalAmount!) * 100;
  }

  // Get offer direction (higher/lower/same)
  OfferDirection get direction {
    if (originalAmount == null) return OfferDirection.unknown;
    if (amount > originalAmount!) return OfferDirection.higher;
    if (amount < originalAmount!) return OfferDirection.lower;
    return OfferDirection.same;
  }

  // Format amount with currency
  String formatAmount(String currency) {
    return '${amount.toStringAsFixed(2)} $currency';
  }

  // Get time remaining until expiration
  Duration? get timeRemaining {
    if (expiresAt == null) return null;
    final remaining = expiresAt!.difference(DateTime.now());
    return remaining.isNegative ? Duration.zero : remaining;
  }

  // Check if offer is from passenger
  bool get isFromPassenger => userType == UserType.passenger;

  // Check if offer is from driver
  bool get isFromDriver => userType == UserType.driver;

  factory CounterOffer.fromJson(Map<String, dynamic> json) =>
      _$CounterOfferFromJson(json);
  Map<String, dynamic> toJson() => _$CounterOfferToJson(this);
}

@JsonSerializable()
class CounterOfferTemplate extends SerializableEntity {
  @override
  int? id;

  String templateId;
  String name;
  String? description;
  UserType targetUserType;
  List<CounterOfferRule> rules;
  bool isActive;
  DateTime createdAt;
  DateTime? updatedAt;
  int? createdBy;

  CounterOfferTemplate({
    this.id,
    required this.templateId,
    required this.name,
    this.description,
    required this.targetUserType,
    this.rules = const [],
    this.isActive = true,
    required this.createdAt,
    this.updatedAt,
    this.createdBy,
  });

  // Generate counter offer based on template rules
  double? generateCounterOffer(
      double originalAmount, Map<String, dynamic> context) {
    for (final rule in rules) {
      if (rule.matches(context)) {
        return rule.calculateAmount(originalAmount);
      }
    }
    return null;
  }

  factory CounterOfferTemplate.fromJson(Map<String, dynamic> json) =>
      _$CounterOfferTemplateFromJson(json);
  Map<String, dynamic> toJson() => _$CounterOfferTemplateToJson(this);
}

@JsonSerializable()
class CounterOfferRule extends SerializableEntity {
  @override
  int? id;

  String ruleId;
  String name;
  Map<String, dynamic> conditions;
  CounterOfferStrategy strategy;
  double? fixedAmount;
  double? percentageAdjustment;
  double? minimumAmount;
  double? maximumAmount;
  int priority;

  CounterOfferRule({
    this.id,
    required this.ruleId,
    required this.name,
    this.conditions = const {},
    required this.strategy,
    this.fixedAmount,
    this.percentageAdjustment,
    this.minimumAmount,
    this.maximumAmount,
    this.priority = 0,
  });

  // Check if rule conditions match context
  bool matches(Map<String, dynamic> context) {
    for (final entry in conditions.entries) {
      final key = entry.key;
      final expectedValue = entry.value;
      final actualValue = context[key];

      if (actualValue != expectedValue) {
        return false;
      }
    }
    return true;
  }

  // Calculate counter offer amount based on strategy
  double calculateAmount(double originalAmount) {
    double calculatedAmount;

    switch (strategy) {
      case CounterOfferStrategy.fixed:
        calculatedAmount = fixedAmount ?? originalAmount;
        break;
      case CounterOfferStrategy.percentage:
        final adjustment = percentageAdjustment ?? 0.0;
        calculatedAmount = originalAmount * (1 + adjustment / 100);
        break;
      case CounterOfferStrategy.incremental:
        calculatedAmount = originalAmount + (fixedAmount ?? 0.0);
        break;
      case CounterOfferStrategy.decremental:
        calculatedAmount = originalAmount - (fixedAmount ?? 0.0);
        break;
    }

    // Apply min/max constraints
    if (minimumAmount != null && calculatedAmount < minimumAmount!) {
      calculatedAmount = minimumAmount!;
    }
    if (maximumAmount != null && calculatedAmount > maximumAmount!) {
      calculatedAmount = maximumAmount!;
    }

    return calculatedAmount;
  }

  factory CounterOfferRule.fromJson(Map<String, dynamic> json) =>
      _$CounterOfferRuleFromJson(json);
  Map<String, dynamic> toJson() => _$CounterOfferRuleToJson(this);
}

enum CounterOfferStatus {
  pending,
  accepted,
  rejected,
  expired,
  withdrawn,
}

enum OfferDirection {
  higher,
  lower,
  same,
  unknown,
}

enum CounterOfferStrategy {
  fixed,
  percentage,
  incremental,
  decremental,
}
